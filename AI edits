import javafx.event.*;
import javafx.scene.*;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.control.*;
import javafx.scene.image.*;
import javafx.scene.canvas.*;
import javafx.scene.layout.*;
import javafx.animation.*;
import javafx.application.*;
import javafx.geometry.*;
import javafx.stage.*;
import java.util.*;
import javafx.scene.paint.Color;
import java.io.*;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.*;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.scene.image.Image;
import javafx.scene.paint.ImagePattern;

public class AI {
   // ... previous code remains the same until t1_GraphB class ...

   public class t1_GraphB {
      ArrayList<t1_Node> theNodes = new ArrayList<t1_Node>();
      HashMap<String, ArrayList<t1_Node>> breakTileNodes = new HashMap<>();
   
      // ... constructor and other methods remain the same ...

      public void removeNodeAndConnections(t1_Node nodeToRemove) {
         // Remove connections from all other nodes to this node
         for(t1_Node node : theNodes) {
            for(int i = 0; i < node.connections.size(); i++) {
               if(node.connections.get(i) == nodeToRemove) {
                  node.connections.remove(i);
                  i--;
               }
            }
         }
         // Remove the node itself
         theNodes.remove(nodeToRemove);
      }
      
      public void updateBreak(Level.LevelIterator currentLevel) {
         // Make a copy of the keys to avoid concurrent modification
         Set<String> breakTileKeys = new HashSet<>(breakTileNodes.keySet());
         
         for(String tileKey : breakTileKeys) {
            String[] coords = tileKey.split("_");
            int x = Integer.parseInt(coords[0]);
            int y = Integer.parseInt(coords[1]);
            
            Level.TileWrapper tw = currentLevel.getSpecificTile(x, y);
            
            if(tw == null) {
               // Break tile is gone, remove all associated nodes and their connections
               ArrayList<t1_Node> nodesToRemove = breakTileNodes.get(tileKey);
               for(t1_Node node : nodesToRemove) {
                  removeNodeAndConnections(node);
               }
               breakTileNodes.remove(tileKey);
            } else {
               // Update break timer for all associated nodes
               ArrayList<t1_Node> nodes = breakTileNodes.get(tileKey);
               for(t1_Node node : nodes) {
                  node.setBreakAmount(tw.getBreakTimer());
               }
            }
         }
      }
      
      // ... rest of the code remains the same ...
   }
   
   public class t1_Node {
      ArrayList<t1_Node> connections = new ArrayList<t1_Node>();
      int x,y;
      int id;
      static int idgen=0;
      double currentBreakAmount=0;
      double maxBreakAmount=0;
      
      public t1_Node(int _x, int _y) {
         x = _x;
         y = _y;
         id = idgen++;
      }
      
      // ... rest of t1_Node implementation remains the same ...
   }
}